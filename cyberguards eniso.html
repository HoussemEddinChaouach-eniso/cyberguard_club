<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ENISO CyberGuards - CTF Challenge</title>
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://cyberguards-ctf.onrender.com">
    <meta property="og:title" content="ENISO CyberGuards - CTF Challenge">
    <meta property="og:description" content="Join the ENISO CyberGuards Capture The Flag challenge! Test your cybersecurity skills with rotating flags and dynamic challenges.">
    <meta property="og:image" content="https://cyberguards-ctf.onrender.com/555583855_24639221942363942_7575546805787447300_n.jpg">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://cyberguards-ctf.onrender.com">
    <meta property="twitter:title" content="ENISO CyberGuards - CTF Challenge">
    <meta property="twitter:description" content="Join the ENISO CyberGuards Capture The Flag challenge! Test your cybersecurity skills with rotating flags and dynamic challenges.">
    <meta property="twitter:image" content="https://cyberguards-ctf.onrender.com/555583855_24639221942363942_7575546805787447300_n.jpg">
    
    <meta name="description" content="ENISO CyberGuards CTF Challenge - Test your cybersecurity skills with dynamic flag rotation and real-time challenges.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(45deg, #000000 0%, #151B54 50%, #000000 100%);
            color: #FFFFFF;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(255, 255, 255, 0.03) 2px,
                rgba(255, 255, 255, 0.03) 4px
            );
            pointer-events: none;
            z-index: 1;
        }

        .glitch-container {
            position: relative;
            margin-bottom: 30px;
            z-index: 2;
        }

        .logo {
            max-width: 300px;
            width: 80%;
            filter: contrast(1.2) brightness(0.8) drop-shadow(0 0 15px rgba(255, 255, 255, 0.1));
            animation: subtlePulse 4s ease-in-out infinite;
            opacity: 0.9;
        }

        @keyframes subtlePulse {
            0%, 100% { opacity: 0.9; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.02); }
        }

        .container {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #151B54;
            border-radius: 0;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 0 50px rgba(21, 27, 84, 0.3),
                0 10px 30px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            position: relative;
            z-index: 2;
        }

        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, 
                rgba(21, 27, 84, 0.1) 0%, 
                rgba(0, 0, 0, 0.9) 50%, 
                rgba(21, 27, 84, 0.1) 100%);
            pointer-events: none;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.8em;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
            color: #FFFFFF;
            letter-spacing: 2px;
            font-weight: 300;
            position: relative;
            z-index: 3;
        }

        .subtitle {
            text-align: center;
            color: #151B54;
            margin-bottom: 30px;
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.8;
            position: relative;
            z-index: 3;
        }

        .challenge-text {
            background: rgba(21, 27, 84, 0.2);
            padding: 20px;
            border: none;
            border-left: 2px solid #FFFFFF;
            margin-bottom: 30px;
            line-height: 1.6;
            font-size: 0.9em;
            color: #FFFFFF;
            position: relative;
            z-index: 3;
        }

        .challenge-text::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 10px,
                rgba(255, 255, 255, 0.01) 10px,
                rgba(255, 255, 255, 0.01) 20px
            );
        }

        .input-group {
            margin-bottom: 20px;
            position: relative;
            z-index: 3;
        }

        input[type="text"] {
            width: 100%;
            padding: 15px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #151B54;
            border-radius: 0;
            color: #FFFFFF;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            transition: all 0.3s ease;
            outline: none;
        }

        input[type="text"]:focus {
            border-color: #FFFFFF;
            box-shadow: 
                0 0 0 1px #FFFFFF,
                inset 0 0 10px rgba(21, 27, 84, 0.5);
            background: rgba(21, 27, 84, 0.2);
        }

        input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.4);
            font-style: italic;
        }

        button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #151B54 0%, #000000 100%);
            border: 1px solid #FFFFFF;
            border-radius: 0;
            color: #FFFFFF;
            font-weight: 300;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            z-index: 3;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            background: linear-gradient(135deg, #000000 0%, #151B54 100%);
            box-shadow: 
                0 0 20px rgba(255, 255, 255, 0.1),
                inset 0 0 20px rgba(21, 27, 84, 0.3);
        }

        button:active {
            transform: scale(0.98);
        }

        .message {
            margin-top: 20px;
            padding: 15px;
            border-radius: 0;
            text-align: center;
            font-weight: 300;
            display: none;
            position: relative;
            z-index: 3;
        }

        .success {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #FFFFFF;
            color: #FFFFFF;
            display: block;
            animation: fadeInUp 0.5s ease-out;
        }

        .error {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #151B54;
            color: #FFFFFF;
            display: block;
            animation: shake 0.5s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .hint {
            margin-top: 20px;
            padding: 15px;
            background: rgba(21, 27, 84, 0.3);
            border: none;
            border-left: 1px solid #FFFFFF;
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.7);
            position: relative;
            z-index: 3;
        }

        .stats {
            margin-top: 20px;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.8em;
            position: relative;
            z-index: 3;
        }
    </style>
</head>
<body>
    <div class="glitch-container">
        <img src="555583855_24639221942363942_7575546805787447300_n.jpg" alt="ENISO CyberGuards" class="logo">
    </div>

    <div class="container">
        <h1>◦ ACCESS RESTRICTED ◦</h1>
        <p class="subtitle">AUTHORIZATION REQUIRED</p>
        
        <div class="challenge-text">
            <p><strong>CLASSIFIED:</strong> Restricted access zone detected.</p>
            <p style="margin-top: 10px;">Authentication token required for entry...</p>
            <p style="margin-top: 10px; font-size: 0.85em; color: rgba(255,255,255,0.7);">
                <strong>⚡ SUBMISSION-BASED ROTATION:</strong> When someone submits the correct token, it immediately rotates to the next one and becomes permanently blocked.
            </p>
        </div>

        <div class="input-group">
            <input type="text" id="flagInput" placeholder="Enter access token..." autocomplete="off">
        </div>

        <button onclick="checkFlag()">AUTHENTICATE</button>

        <div id="message" class="message"></div>

        <div class="hint">
            <strong>◦ HINT:</strong> Sometimes what appears empty contains the most valuable secrets. Look beyond the surface...
            <br><br>
            <strong>◦ ROTATION:</strong> Each token can only be used ONCE! When someone submits it correctly, it becomes blocked forever and rotates to the next one.
            <br><br>
            <strong>◦ RACE:</strong> Be fast! Once someone else submits the current token, you'll need to find the new one.
        </div>

        <div class="stats" id="stats">
            Access Attempts: <span id="attempts">0</span> | Successful Authentications: <span id="solves">0</span>
            <br>
            <span id="timer" style="color: #FFFFFF; font-weight: bold; margin-top: 5px; display: block;">
                Next rotation in: --:--
            </span>
        </div>
    </div>

    <!-- The flag is hidden here in the HTML comments and obfuscated in JavaScript -->
    <!-- But which one is the real flag? -->
    <!-- flag{fake_flag_try_harder} -->
    <!-- flag{n0t_th1s_0ne_either} -->
    
    <script>
        // Current state variables
        let currentFlagIndex = 0; // This will be Q from server
        let attempts = 0;
        let Q = 0; // Number of people who solved correctly (current flag index)
        let timeUntilNextRotation = 0;
        let countdownInterval;

        // Flag rotation list - obfuscated
const flagList = [
    'QzdCM1JfR1U0UkRfRW4xNTA=',
    'Q3liM3JHdTRyZEVuMTVv',
    'Y3liM3JfZ3U0cmRfZW4xNW8=',
    'Y3liZXJfZ3U0cmRfZW5pNW8=',
    'Y3liM3JfZ3U0cmRfM24xc28=',
    'Q3liM3JHdWFyZEVuMTVv',
    'Y3liZXJfZ3U0cmRfM24xc28=',
    'Q3liM3JfZ3VhcmRfZW5pNW8=',
    'VV9EMWRFMVQ=',
    'QzBuZ3I0dDVfdV9kMWRfMXQ=',
    'Q3liM3ItZ3VhcmRfRW5pc28=',
    'Q3liM3IuR1VBUkRFbjE1MA==',
    'Y3liM3JfR1VBUkQtM24xc28=',
    'Q3liM3JfR3U0cmQuRW5pc28=',
    'Y3liZXJHdTRyZEVOMVNP',
    'Q1lCM1ItZ3U0cmQuRU5JU08=',
    'Q3liZXItR1U0UkRfRU4xU08=',
    'Q3liZXIuR1U0UkQuRW4xNTA=',
    'Y3liM3JfR1VBUkQtRU4xNU8=',
    'Q1lCM1JfR1VBUkQuRW5pc28=',
    'Q1lCM1IuR3U0cmRlbmk1bw==',
    'Q3liZXJHdTRyZC1FTjFTTw==',
    'Q1lCM1JHdTRyZF9lbmk1bw==',
    'Y1liM3IuZ3U0cmRfRW4xc28=',
    'Q1lCM1ItR1VBUkQuRW4xc28=',
    'Q3liZXJfR3U0cmRFTklTTw==',
    'Y3liM3ItR3U0cmQuZW4xNTA=',
    'Q3liM3IuR3U0cmRfM24xc28=',
    'Q1lCRVJHdTRyZC1Fbmlzbw==',
    'Y3liM3JfR3U0cmQuZW4xc28=',
    'Y3liZXItR1VBUkQuRW4xNTA=',
    'Q3liM3IuR3U0cmQuZW4xNTA=',
    'Q1lCM1JfR1VBUkQuRW5pc28=',
    'Q1lCM1IuR3U0cmRlbmk1bw==',
    'Q3liZXJHdTRyZC1FTjFTTw==',
    'Y3liM3JfR3U0cmQuZW4xc28=',
    'Y3liM3JfR3U0cmQuZW4xc28=',
    'Q3liM3JfZ3VhcmRfRW5pc28=',
    'Q3liM3IuR1VBUkRFbjE1MA==',
    'Y3liM3JfR1VBUkQtM24xc28=',
    'Q3liM3JfR3U0cmQuRW5pc28=',
    'Y3liZXJHdTRyZEVOMVNP',
    'Q3liM3ItZ3VhcmRfRW5pc28=',
    'Q3liM3IuR1VBUkRFbjE1MA==',
    'Y3liM3JfR1VBUkQtM24xc28=',
    'Q3liM3JfR3U0cmQuRW5pc28=',
    'Y3liZXJHdTRyZEVOMVNP',
    'Q3liM3ItZ3VhcmRfRW5pc28=',
    'Q3liM3IuR1VBUkRFbjE1MA==',
    'Y3liM3JfR1VBUkQtM24xc28=',
    'Q3liM3JfR3U0cmQuRW5pc28=',
    'Y3liZXJHdTRyZEVOMVNP',
    'Q3liM3ItZ3VhcmRfRW5pc28=',
    'Q3liM3IuR1VBUkRFbjE1MA==',
    'Y3liM3JfR1VBUkQtM24xc28=',
    'Q3liM3JfR3U0cmQuRW5pc28=',
    'Y3liZXJHdTRyZEVOMVNP',
    'Q3liM3ItZ3VhcmRfRW5pc28=',
    'Q3liM3IuR1VBUkRFbjE1MA==',
    'Y3liM3JfR1VBUkQtM24xc28=',
    'Q3liM3JfR3U0cmQuRW5pc28=',
    'Y3liZXJHdTRyZEVOMVNP',
    'Q3liM3ItZ3VhcmRfRW5pc28=',
    'Q3liM3IuR1VBUkRFbjE1MA==',
    'Y3liM3JfR1VBUkQtM24xc28=',
    'Q3liM3JfR3U0cmQuRW5pc28=',
    'Y3liZXJHdTRyZEVOMVNP',
    'Q3liM3ItZ3VhcmRfRW5pc28=',
    'Q3liM3IuR1VBUkRFbjE1MA==',
    'Y3liM3JfR1VBUkQtM24xc28=',
    'Q3liM3JfR3U0cmQuRW5pc28=',
    'Y3liZXJHdTRyZEVOMVNP',
    'Q3liM3ItZ3VhcmRfRW5pc28=',
    'Q3liM3IuR1VBUkRFbjE1MA==',
    'Y3liM3JfR1VBUkQtM24xc28=',
    'Q3liM3JfR3U0cmQuRW5pc28='
];

        // Define checkFlag function early to prevent "not defined" errors
        async function checkFlag() {
            const input = document.getElementById('flagInput').value.trim();
            const messageEl = document.getElementById('message');

            if (!input) {
                messageEl.className = 'message error';
                messageEl.textContent = '◦ ACCESS DENIED ◦ Please enter an authentication token.';
                setTimeout(() => {
                    messageEl.style.display = 'none';
                }, 3000);
                return;
            }

            // Submit flag to server for validation and immediate rotation
            try {
                const response = await fetch('/api/flag-state', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        action: 'validate_and_submit_flag',
                        submittedFlag: input
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data.success) {
                        // Flag was correct - use server-provided data for perfect sync
                        Q = data.newQ || data.Q; // Use server's new Q value
                        currentFlagIndex = Q; // Move to next flag in list
                        attempts = data.attempts || attempts;
                        
                        // Use server-provided encrypted flag to ensure perfect sync
                        const newEncryptedFlag = data.currentFlagEncrypted || flagList[currentFlagIndex] || flagList[Q];
                        
                        updateStats();
                        document.body.setAttribute('dataencrypted', newEncryptedFlag);
                        console.log(`✅ SUCCESS: Advanced to next flag! dataencrypted = ${newEncryptedFlag} (Q=${Q})`);
                        
                        // Update localStorage to persist the progression
                        localStorage.setItem('ctf_Q', Q);
                        localStorage.setItem('ctf_current_flag_index', currentFlagIndex);
                        localStorage.setItem('ctf_attempts', attempts);
                        localStorage.setItem('ctf_last_updated', Date.now());
                        
                        messageEl.className = 'message success';
                        const rotationInfo = data.rotationTriggered ? 
                            `<br><span style="font-size: 0.8em; opacity: 0.8;">Flag rotated from Q=${data.previousQ} to Q=${data.newQ}</span>` : '';
                        messageEl.innerHTML = `
                            ◦ ACCESS GRANTED ◦<br>
                            <strong>TOKEN ACCEPTED & ROTATED</strong>${rotationInfo}<br>
                            <span style="font-size: 0.9em; margin-top: 10px; display: block;">
                            Token is now BLOCKED forever. All users will see the new token. Redirecting to form...
                            </span>
                        `;

                        // If global refresh is needed, trigger it for all other users
                        if (data.globalRefresh) {
                            console.log('🌐 Global refresh triggered - other users will see new flag');
                            // The polling mechanism will handle updating other users
                        }

                        // Redirect to the Google Form after a short delay
                        setTimeout(() => {
                            window.location.href = 'https://docs.google.com/forms/d/e/1FAIpQLScxw6hkaqiW9lUfGmLPlJMX4cpkh7_q5K8pfLqFldWN3THkOg/viewform?usp=send_form';
                        }, 3000);
                    } else {
                        // Flag was incorrect or blocked
                        attempts = data.attempts;
                        updateStats();
                        
                        messageEl.className = 'message error';
                        
                        if (data.flagBlocked) {
                            // Special handling for blocked flags
                            messageEl.innerHTML = `
                                ◦ FLAG BLOCKED ◦<br>
                                <strong>This token has already been used</strong><br>
                                <span style="font-size: 0.9em; margin-top: 10px; display: block;">
                                Someone else submitted it first. Find the current active token.
                                </span>
                            `;
                            
                            // Force refresh the current flag from server
                            setTimeout(async () => {
                                try {
                                    const refreshResponse = await fetch('/api/flag-state');
                                    if (refreshResponse.ok) {
                                        const refreshData = await refreshResponse.json();
                                        Q = refreshData.Q;
                                        currentFlagIndex = Q;
                                        updateStats();
                                        // Use server-provided encrypted flag for perfect sync
                                        const serverEncryptedFlag = refreshData.currentFlagEncrypted || flagList[currentFlagIndex];
                                        document.body.setAttribute('dataencrypted', serverEncryptedFlag);
                                        console.log(`🔄 BLOCKED REFRESH: Updated dataencrypted to: ${serverEncryptedFlag} (Q=${Q})`);
                                    }
                                } catch (error) {
                                    console.error('Failed to refresh flag state:', error);
                                }
                            }, 1000);
                        } else {
                            // Regular incorrect flag
                            messageEl.textContent = '◦ ACCESS DENIED ◦ Invalid authentication token.';
                        }
                        
                        // Clear error message after 5 seconds
                        setTimeout(() => {
                            messageEl.style.display = 'none';
                        }, 5000);
                    }
                } else {
                    console.error('Flag submission failed:', response.status, response.statusText);
                    messageEl.className = 'message error';
                    messageEl.textContent = '◦ SYSTEM ERROR ◦ Unable to validate token. Please try again.';
                    setTimeout(() => {
                        messageEl.style.display = 'none';
                    }, 5000);
                }
            } catch (error) {
                console.error('Error submitting flag:', error);
                messageEl.className = 'message error';
                messageEl.textContent = '◦ CONNECTION ERROR ◦ Please check your connection and try again.';
                setTimeout(() => {
                    messageEl.style.display = 'none';
                }, 5000);
            }
        }

        // Load state from server API with better error handling
        async function loadState() {
            let serverData = null;
            try {
                console.log('📡 Fetching current state from server...');
                const response = await fetch('/api/flag-state', {
                    method: 'GET',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    serverData = data; // Store for later use
                    const serverQ = data.Q || 0;
                    
                    // Always use server state as the source of truth
                    Q = serverQ;
                    currentFlagIndex = Q;
                    attempts = data.attempts || 0;
                    timeUntilNextRotation = data.timeUntilNextRotation || 0;
                    
                    console.log(`✅ Updated from server: Q=${Q}, currentFlagIndex=${currentFlagIndex}, attempts=${attempts}`);
                    
                    // Save server state to localStorage for offline fallback
                    localStorage.setItem('ctf_Q', Q);
                    localStorage.setItem('ctf_current_flag_index', currentFlagIndex);
                    localStorage.setItem('ctf_attempts', attempts);
                    localStorage.setItem('ctf_last_updated', data.lastUpdated);
                    
                    console.log(`📊 Final state: Q=${Q}, currentFlagIndex=${currentFlagIndex}, attempts=${attempts}`);
                    
                    // Start countdown timer if we have rotation time
                    if (timeUntilNextRotation > 0) {
                        startCountdown();
                    }
                } else {
                    console.error('❌ Server response not ok:', response.status);
                    throw new Error(`Server response ${response.status}`);
                }
            } catch (error) {
                console.error('❌ Failed to load state from server:', error);
                
                // Try one more time after a delay before falling back
                console.log('🔄 Retrying server connection in 2 seconds...');
                setTimeout(async () => {
                    try {
                        const retryResponse = await fetch('/api/flag-state');
                        if (retryResponse.ok) {
                            const data = await retryResponse.json();
                            Q = data.Q || 0;
                            currentFlagIndex = Q;
                            attempts = data.attempts || 0;
                            updateStats();
                            // Use server-provided encrypted flag for perfect sync
                            const serverEncryptedFlag = data.currentFlagEncrypted || flagList[currentFlagIndex];
                            document.body.setAttribute('dataencrypted', serverEncryptedFlag);
                            console.log('✅ RETRY SUCCESS: Set dataencrypted to:', serverEncryptedFlag, 'Q=', Q);
                            console.log('✅ Successfully loaded state on retry:', { Q, currentFlagIndex, attempts });
                            return;
                        }
                    } catch (retryError) {
                        console.error('❌ Retry also failed:', retryError);
                    }
                    
                    // Only use localStorage as absolute last resort
                    console.warn('⚠️ Using localStorage fallback - may be outdated');
                    const storedQ = parseInt(localStorage.getItem('ctf_Q') || '0');
                    Q = storedQ;
                    currentFlagIndex = Q;
                    attempts = parseInt(localStorage.getItem('ctf_attempts') || '0');
                    console.log(`📱 Fallback state: Q=${Q}, attempts=${attempts}`);
                    updateStats();
                    document.body.setAttribute('dataencrypted', flagList[currentFlagIndex]);
                    console.log(`📱 FALLBACK: Set dataencrypted to: ${flagList[currentFlagIndex]} (Q=${Q})`);
                }, 2000);
            }
            
            updateStats();
            // Update the page attribute with current flag - use server data if available
            const serverFlag = serverData?.currentFlagEncrypted || flagList[currentFlagIndex];
            document.body.setAttribute('dataencrypted', serverFlag);
            console.log(`🔄 LOADSTATE: Set dataencrypted to: ${serverFlag} (Q=${Q})`);
            
            // Force update dataencrypted attribute to ensure it's set correctly
            setTimeout(() => {
                const finalFlag = serverData?.currentFlagEncrypted || flagList[currentFlagIndex];
                document.body.setAttribute('dataencrypted', finalFlag);
                console.log(`🔒 FINAL UPDATE: dataencrypted = ${finalFlag} (Q=${Q})`);
            }, 100);
        }

        // Poll for updates every 2 seconds to catch flag rotations from other users
        function startPolling() {
            setInterval(async () => {
                try {
                    const response = await fetch('/api/flag-state', {
                        headers: { 
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        }
                    });
                    if (response.ok) {
                        const data = await response.json();
                        const serverQ = data.Q || 0;
                        const serverFlagIndex = serverQ; // Current flag is always at index Q
                        
                        // Only update if server has progressed further (someone else submitted)
                        if (serverQ > Q) {
                            console.log(`🔄 Server ahead: Q changed from ${Q} to ${serverQ}`);
                            console.log(`📡 Someone else submitted: Q=${serverQ}, attempts=${data.attempts}`);
                            
                            const oldQ = Q;
                            Q = serverQ;
                            currentFlagIndex = serverQ;
                            attempts = data.attempts || 0;
                            
                            // Update timer info if available
                            if (data.timeUntilNextRotation) {
                                timeUntilNextRotation = data.timeUntilNextRotation;
                                startCountdown();
                            }
                            
                            // Update UI
                            updateStats();
                            // Use server-provided encrypted flag for perfect sync
                            const serverEncryptedFlag = data.currentFlagEncrypted || flagList[currentFlagIndex];
                            document.body.setAttribute('dataencrypted', serverEncryptedFlag);
                            console.log(`🔄 POLLING: Advanced to flag: ${serverEncryptedFlag} (Q=${Q})`);
                            
                            // Save to localStorage for offline fallback
                            localStorage.setItem('ctf_Q', Q);
                            localStorage.setItem('ctf_current_flag_index', currentFlagIndex);
                            localStorage.setItem('ctf_attempts', attempts);
                            localStorage.setItem('ctf_last_updated', data.lastUpdated);
                            
                            // Show a notification that the flag changed (submission-based rotation)
                            if (serverQ > oldQ) {
                                const messageEl = document.getElementById('message');
                                messageEl.className = 'message success';
                                messageEl.innerHTML = `
                                    ⚡ TOKEN ROTATED ⚡<br>
                                    Someone submitted the correct token!<br>
                                    <span style="font-size: 0.8em; margin-top: 5px; display: block;">
                                    Previous token is now BLOCKED. New token active: Q=${Q}.
                                    </span>
                                `;
                                setTimeout(() => {
                                    messageEl.style.display = 'none';
                                }, 6000);
                            }
                        } else {
                            console.log(`📊 Polling: Server Q=${serverQ} <= Local Q=${Q}, keeping local state`);
                        }
                    }
                } catch (error) {
                    console.log('Polling failed:', error.message);
                }
            }, 2000); // Poll every 2 seconds for faster synchronization
        }

        // Function to refresh all users when flag rotates

        function updateStats() {
            document.getElementById('attempts').textContent = attempts;
            document.getElementById('solves').textContent = Q; // Show Q as number of solves
            
            // Save stats to localStorage only as backup (server is authoritative)
            localStorage.setItem('ctf_Q', Q);
            localStorage.setItem('ctf_attempts', attempts);
            localStorage.setItem('ctf_current_flag_index', currentFlagIndex);
            localStorage.setItem('ctf_last_updated', Date.now());
        }

        // Decode current flag
        function getCurrentFlag() {
            return atob(flagList[currentFlagIndex]);
        }

        // Start countdown timer for flag rotation
        function startCountdown() {
            // No countdown needed for submission-based rotation
            const timerEl = document.getElementById('timer');
            if (timerEl) {
                timerEl.textContent = 'Tokens rotate when someone submits the correct one';
            }
        }

        // Hidden flag in page (inspectable) - will be updated after server load
        document.body.setAttribute('dataencrypted', flagList[currentFlagIndex]);
        console.log(`🚀 INITIAL: Set dataencrypted to: ${flagList[currentFlagIndex]} (Q=${Q}) - will update from server`);

        // Allow Enter key to submit
        document.getElementById('flagInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                checkFlag();
            }
        });

        // Hidden traces in console
        console.log('%c◦ RESTRICTED SYSTEM ◦', 'color: #FFFFFF; font-size: 16px; font-weight: bold;');
        console.log('%cUnauthorized access detected...', 'color: #151B54; font-size: 12px;');
        console.log('%cSearching for vulnerabilities? 🔍', 'color: #FFFFFF; font-size: 12px;');
        console.log('%cHint: The void holds secrets...', 'color: rgba(255,255,255,0.5); font-size: 10px;');

        // Initialize - Always load fresh state from server
        console.log('🚀 Initializing CTF Challenge - Loading current state from server...');
        
        // Note: We don't clear localStorage here - let server be the source of truth
        // Only clear if we detect corruption or major version changes
        
        loadState().then(() => {
            console.log(`✅ Initialization complete: Q=${Q}, currentFlagIndex=${currentFlagIndex}`);
            // Start polling for updates after initial load
            startPolling();
        }).catch((error) => {
            console.error('❌ Failed to initialize:', error);
            // Force retry initialization
            setTimeout(() => {
                console.log('🔄 Retrying initialization...');
                loadState().then(() => {
                    startPolling();
                });
            }, 3000);
        });
    </script>
</body>
</html>